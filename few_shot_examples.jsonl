{"query": "SELECT * FROM Robots WHERE Robot_ID = (SELECT Robot_ID FROM Robots WHERE Robot_ID = 1);", "error_type": "construction", "error_subtype": "inefficient query", "feedback": "Your query is valid, but the subquery is redundant. You can simplify it."}
{"query": "SELECT Description FROM Incidents WHERE Robot_ID = (SELECT Robot_ID FROM Incidents i2 WHERE i2.Incident_ID = Incidents.Incident_ID);", "error_type": "construction", "error_subtype": "inefficient query", "feedback": "This query is circular subquery logic. Simplify it."}
{"query": "SELECT * FROM Employees e JOIN Logs l ON e.Employee_ID = l.Employee_ID JOIN Incidents i ON l.Employee_ID = i.Employee_ID WHERE Timestamp = '2020-10-01';", "error_type": "logic", "error_subtype": "ambiguous reference", "feedback": "You have an ambiguous reference - 'Timestamp' could belong to either 'Logs' or 'Incidents'."}
{"query": "SELECT * FROM Employees JOIN Robots ON Employee_ID = Employee_ID;", "error_type": "logic", "error_subtype": "ambiguous reference", "feedback": "You need to qualify the column names with table aliases in JOIN condition."}
{"query": "SELECT i.Robot_ID, COUNT(*) FROM Incidents i GROUP BY ac.Level_of_Access;", "error_type": "logic", "error_subtype": "incorrect GROUP BY usage", "feedback": "You are grouping by column from non-joined table."}
{"query": "SELECT Action_Description, Timestamp FROM Logs GROUP BY Action_Description;", "error_type": "logic", "error_subtype": "incorrect GROUP BY usage", "feedback": "SELECT fields must appear in GROUP BY or be aggregate functions."}
{"query": "SELECT e.Name, l.Action_Description FROM Employees e JOIN Logs l ON e.Employee_ID = l.Employee_ID HAVING e.Job_Role = 'Developer';", "error_type": "logic", "error_subtype": "incorrect HAVING clause", "feedback": "HAVING is meant to filter groups, not individual rows."}
{"query": "SELECT Robot_ID, COUNT(*) FROM Logs GROUP BY Robot_ID HAVING COUNT(*) > 3 AND Robot_ID < 50;", "error_type": "logic", "error_subtype": "incorrect HAVING clause", "feedback": "The HAVING clause should be used for aggregate conditions."}
{"query": "SELECT e.Name, l.Action_Description FROM Employees e JOIN Logs l ON e.Employee_ID = e.Employee_ID;", "error_type": "logic", "error_subtype": "incorrect JOIN usage", "feedback": "Your join condition is always true, which results in a Cartesian product."}
{"query": "SELECT e.Name FROM Employees e INNER JOIN Robots r ON e.Employee_ID = r.Employee_ID AND r.Status = 'Maintenance';", "error_type": "logic", "error_subtype": "incorrect JOIN usage", "feedback": "Putting r.Status = 'Maintenance' in JOIN condition changes the logic. Move it to WHERE clause."}
{"query": "SELECT Robot_ID, Timestamp FROM Logs ORDER BY Robot_ID, 3;", "error_type": "logic", "error_subtype": "incorrect ORDER BY usage", "feedback": "When using positional ordering, the number must match the column position in your SELECT list."}
{"query": "SELECT Job_Role FROM Employees ORDER BY MIN(Employee_ID);", "error_type": "logic", "error_subtype": "incorrect ORDER BY usage", "feedback": "ORDER BY MIN() requires GROUP BY clause."}
{"query": "SELECT * FROM Incidents WHERE Robot_ID = 1001 AND Description = 'Error' OR Description = 'Warning' AND Employee_ID = 2001;", "error_type": "logic", "error_subtype": "operator misuse", "feedback": "The conditions are a bit mixed up. Try grouping them with parentheses to clarify the logic."}
{"query": "SELECT * FROM Logs WHERE Action_Description = 'Login' OR Action_Description = 'Logout' AND Timestamp > '2024-01-01';", "error_type": "logic", "error_subtype": "operator misuse", "feedback": "Try grouping the conditions with parentheses to get the desired result."}
{"query": "DELETE FROM Logs WHERE Description IN ('Login', 'Logout');", "error_type": "schema", "error_subtype": "undefined column", "feedback": "'Description' isn't defined in the table. Try to find the right column."}
{"query": "SELECT * FROM Employees WHERE Age > 30;", "error_type": "schema", "error_subtype": "undefined column", "feedback": "Please carefully review the column names in the Employees table."}
{"query": "SELECT Employee_ID, MAXX(Timestamp_of_Last_Use) FROM Access_Codes GROUP BY Employee_ID;", "error_type": "schema", "error_subtype": "undefined function", "feedback": "In this query, MAXX() is not a valid function in SQL. Maybe you mean MAX()."}
{"query": "SELECT LOWER_CASE(Job_Role) FROM Employees ORDER BY Job_Role;", "error_type": "schema", "error_subtype": "undefined function", "feedback": "LOWER_CASE() is not a valid SQL function."}
{"query": "DELETE FROM Incident WHERE Incident_ID = 10;", "error_type": "schema", "error_subtype": "undefined table", "feedback": "'Incident' is not a valid table."}
{"query": "SELECT Incident_ID, Action_Description FROM Log;", "error_type": "schema", "error_subtype": "undefined table", "feedback": "Double-check your table name in the database."}
{"query": "SELECT MAX() FROM Incidents;", "error_type": "syntax", "error_subtype": "aggregation misuse", "feedback": "MAX needs a column parameter."}
{"query": "SELECT Job_Role, COUNT FROM Employees GROUP BY Job_Role;", "error_type": "syntax", "error_subtype": "aggregation misuse", "feedback": "COUNT requires parentheses to enclose its parameter."}
{"query": "UPDATE Access_Codes SET Level_of_Access = 'Admin' WHERE Access_Code_ID = '1';", "error_type": "syntax", "error_subtype": "data type mismatch", "feedback": "Access_Code_ID expects a number, not a string."}
{"query": "SELECT r.Model, i.Description FROM Robots r JOIN Incidents i ON r.Robot_ID = i.Robot_ID WHERE r.Status = 1;", "error_type": "syntax", "error_subtype": "data type mismatch", "feedback": "Use quotes for string values such as Status."}
{"query": "SELECT Incident_ID FROM Incidents WHERE Description LIKE;", "error_type": "syntax", "error_subtype": "incomplete query", "feedback": "Your WHERE clause is incomplete. You need to add a string pattern following the LIKE operator."}
{"query": "SELECT Log_ID, Employee_ID, Action_Description as FROM Logs;", "error_type": "syntax", "error_subtype": "incomplete query", "feedback": "You need to add valid alias names following the AS keyword."}
{"query": "SELECT Employee_ID, COUNT(DISTINCT Action_Description) AS Action_Count FROM Logs GROUP BY DISTINCT Employee_ID;", "error_type": "syntax", "error_subtype": "incorrect DISTINCT usage", "feedback": "DISTINCT can't be used in GROUP BY."}
{"query": "SELECT DISTINCT e.Employee_ID, ac.Level_of_Access FROM Access_Codes ac JOIN Employees e ON ac.Employee_ID = e.Employee_ID ORDER BY DISTINCT ac.Level_of_Access;", "error_type": "syntax", "error_subtype": "incorrect DISTINCT usage", "feedback": "DISTINCT can't be used in the ORDER BY clause! Try removing it to fix the query."}
{"query": "SELECT Robot_ID, FROM Robots;", "error_type": "syntax", "error_subtype": "incorrect SELECT usage", "feedback": "You have a trailing comma after Robot_ID."}
{"query": "SELECT ALL Employee_ID, Name FROM Employees;", "error_type": "syntax", "error_subtype": "incorrect SELECT usage", "feedback": "ALL is not standard after SELECT (use DISTINCT or nothing)."}
{"query": "SELECT * FROM Employees WHERE Name CONTAINS '%John%';", "error_type": "syntax", "error_subtype": "incorrect wildcard usage", "feedback": "Use LIKE with wildcards instead of CONTAINS."}
{"query": "SELECT Model FROM Robots WHERE Status LIKE 'Inactive';", "error_type": "syntax", "error_subtype": "incorrect wildcard usage", "feedback": "LIKE is used for wildcard patterns. If you're looking for an exact match, use '=' instead."}
{"query": "UPDATE Employees SET Job_Role = 'Manager' Division = 'HR' WHERE Employee_ID = 101;", "error_type": "syntax", "error_subtype": "missing commas", "feedback": "Add a comma between SET assignments."}
{"query": "SELECT r.Status l.Action_Description FROM Robots r JOIN Logs l ON r.Robot_ID = l.Robot_ID;", "error_type": "syntax", "error_subtype": "missing commas", "feedback": "You need to separate column names with commas."}
{"query": "SELECT * FROM Employees WHERE Name = John;", "error_type": "syntax", "error_subtype": "missing quotes", "feedback": "Remember to always use quotes around string values in SQL queries."}
{"query": "UPDATE Employees SET Job_Role = Manager WHERE Employee_ID = 10;", "error_type": "syntax", "error_subtype": "missing quotes", "feedback": "Use quotes around string literals."}
{"query": "DELETE FROM Employees WHERE Employee_ID = 9", "error_type": "syntax", "error_subtype": "missing semicolons", "feedback": "You need to add a semicolon at the end."}
{"query": "SELECT Model, Status FROM Robots WHERE Robot_ID = 2", "error_type": "syntax", "error_subtype": "missing semicolons", "feedback": "Remember to add a semicolon at the end of the query."}
{"query": "SELECT r.Model, COUNT(*) FROM Robots r RIGTH JOIN Logs l ON r.Robot_ID = l.Robot_ID GROUP BY r.Model;", "error_type": "syntax", "error_subtype": "misspelling", "feedback": "Correct the typo for JOIN keywords."}
{"query": "SELECT * FROM Access_Codes WHERE Employee_ID IS NTO NULL;", "error_type": "syntax", "error_subtype": "misspelling", "feedback": "Fix the typo for NOT."}
{"query": "SELECT e.Name, (r.Status == 'Active' ? 'Working' : 'Not Working') FROM Employees e JOIN Robots r ON e.Employee_ID = r.Employee_ID;", "error_type": "syntax", "error_subtype": "non-standard operators", "feedback": "You used the ?: ternary operator and == in SQL. SQL does not support the ternary syntax."}
{"query": "SELECT r.Robot_ID, i.Description FROM Robots r LEFT JOIN Incidents i ON r.Robot_ID = i.Robot_ID WHERE r.Status = 'Maintenance' AND i.Timestamp >> '2024-01-01';", "error_type": "syntax", "error_subtype": "non-standard operators", "feedback": "You used >> in the WHERE clause, but SQL uses > for date comparison."}
{"query": "SELECT Employee_ID, COUNT(Log_ID) FROM Logs GROUP BY Employee_ID HAVING COUNT(Log_ID)) > 1;", "error_type": "syntax", "error_subtype": "unmatched brackets", "feedback": "Your HAVING clause has an extra closing parenthesis."}
{"query": "SELECT Employee_ID FROM Access_Codes WHERE Level_of_Access IN ('admin', 'guest', 'temp';", "error_type": "syntax", "error_subtype": "unmatched brackets", "feedback": "Missing closing parenthesis in IN clause."}
{"query": "SET Manufacturing_Date = '2024-01-01' WHERE Status = 'Active' UPDATE Robots;", "error_type": "syntax", "error_subtype": "wrong positioning", "feedback": "UPDATE comes first then SET then WHERE."}
{"query": "SELECT * FROM Logs l ON l.Robot_ID = r.Robot_ID INNER JOIN Robots r;", "error_type": "syntax", "error_subtype": "wrong positioning", "feedback": "The INNER JOIN with ON condition is misplaced in the FROM clause."}
